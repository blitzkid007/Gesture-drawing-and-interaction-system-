<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI çº¯å‡€ç©ºä¸­ç”»æ¿ - åŸå§‹æ¯”ä¾‹ç‰ˆ</title>
    <!-- å¼•å…¥ MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils@0.6/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.3/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/hands.js" crossorigin="anonymous"></script>

    <style>
        body { margin: 0; padding: 0; overflow: hidden; background-color: #111; font-family: 'Segoe UI', sans-serif; }
        
        /* éšè—åŸå§‹è§†é¢‘å…ƒç´  */
        #input_video { display: none; }
        
        /* ç”»å¸ƒå…¨å±ï¼Œå¹¶è¿›è¡Œæ°´å¹³é•œåƒç¿»è½¬ï¼Œå®ç°â€œç…§é•œå­â€ä½“éªŒ */
        #output_canvas {
            position: absolute; left: 0; top: 0; width: 100%; height: 100%;
            z-index: 1;
            transform: scaleX(-1); 
        }

        /* çŠ¶æ€æç¤º */
        #status_indicator {
            position: absolute; top: 20px; left: 20px; z-index: 10;
            padding: 8px 16px; background: rgba(0,0,0,0.6); color: rgba(255,255,255,0.9);
            border-radius: 20px; font-size: 14px; font-weight: 500; pointer-events: none;
            backdrop-filter: blur(4px);
        }

        /* æç®€ UI å·¥å…·æ  */
        #ui_layer {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            z-index: 10; display: flex; gap: 15px; padding: 10px 25px;
            background: rgba(30, 30, 30, 0.85); /* æ·±è‰²ç£¨ç ‚é£æ ¼ */
            border-radius: 60px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            align-items: center; justify-content: center;
        }

        .tool-btn {
            width: 50px; height: 50px; border-radius: 50%; border: 2px solid transparent;
            cursor: pointer; display: flex; justify-content: center; align-items: center;
            font-size: 22px; background-color: rgba(255,255,255,0.1); color: white; transition: all 0.2s;
        }
        
        .tool-btn:hover { background-color: rgba(255,255,255,0.2); }
        .tool-btn.active { transform: scale(1.1); border-color: #00e5ff; background-color: rgba(0, 229, 255, 0.2); color: #00e5ff; box-shadow: 0 0 15px rgba(0, 229, 255, 0.3); }

        .divider { width: 1px; height: 25px; background: rgba(255,255,255,0.2); margin: 0 5px; }

        .color-btn { width: 32px; height: 32px; border-radius: 50%; border: 2px solid rgba(255,255,255,0.5); cursor: pointer; transition: transform 0.2s; }
        .color-btn.active { transform: scale(1.3); border-color: white; box-shadow: 0 0 10px rgba(255,255,255,0.5); }
        
        /* æ¸…ç©ºæŒ‰é’® */
        .tool-btn.clear-btn { color: #ff5252; }
        .tool-btn.clear-btn:hover { background-color: rgba(255, 82, 82, 0.2); }

    </style>
</head>
<body>

    <video id="input_video"></video>
    <canvas id="output_canvas"></canvas>
    
    <div id="status_indicator">æ­£åœ¨æ ¡å‡†æ‘„åƒå¤´...</div>

    <div id="ui_layer">
        <div class="tool-btn active" id="btn-brush" data-tool="brush" title="ç”»ç¬”">ğŸ–Œï¸</div>
        <div class="tool-btn" id="btn-eraser" data-tool="eraser" title="æ©¡çš®æ“¦ (è§¦ç¢°å³æ¶ˆ)">âš¡</div>
        <div class="tool-btn clear-btn" id="btn-clear" data-tool="clear" title="æ¸…ç©ºç”»æ¿">ğŸ—‘ï¸</div>
        
        <div class="divider"></div>
        
        <div class="color-btn active" style="background: #ffffff;" data-color="#ffffff"></div>
        <div class="color-btn" style="background: #ff4081;" data-color="#ff4081"></div>
        <div class="color-btn" style="background: #00e5ff;" data-color="#00e5ff"></div>
        <div class="color-btn" style="background: #76ff03;" data-color="#76ff03"></div>
        <div class="color-btn" style="background: #ffd740;" data-color="#ffd740"></div>
    </div>

<script>
    const videoElement = document.getElementById('input_video');
    const canvasElement = document.getElementById('output_canvas');
    const ctx = canvasElement.getContext('2d');
    const statusDiv = document.getElementById('status_indicator');
    
    // åˆå§‹åŒ–ç”»å¸ƒå°ºå¯¸
    let screenW = window.innerWidth;
    let screenH = window.innerHeight;
    canvasElement.width = screenW;
    canvasElement.height = screenH;

    // --- æ ¸å¿ƒçŠ¶æ€ ---
    const STATE = {
        tool: 'brush', 
        color: '#ffffff',
        baseSize: 10, 
        isDrawing: false,
        strokes: [], // ç¬”ç”»æ•°æ®
        
        // å¹³æ»‘åæ ‡
        smoothedX: 0,
        smoothedY: 0,
        
        // ç”»é¢é€‚é…å‚æ•° (ç”¨äºè§£å†³æ‹‰ä¼¸é—®é¢˜)
        videoLayout: { x: 0, y: 0, w: 0, h: 0 }
    };

    // --- MediaPipe Hands ---
    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/${file}`});
    hands.setOptions({
        maxNumHands: 1, // çº¯å‡€æ¨¡å¼å•æ‰‹å³å¯
        modelComplexity: 1,
        minDetectionConfidence: 0.7,
        minTrackingConfidence: 0.7
    });
    hands.onResults(onResults);

    const camera = new Camera(videoElement, {
        onFrame: async () => { await hands.send({image: videoElement}); },
        width: 1280, height: 720
    });
    camera.start();

    // --- å‡ ä½•å·¥å…·å‡½æ•° ---
    function dist(p1, p2) { return Math.hypot(p1.x - p2.x, p1.y - p2.y); }
    function mid(p1, p2) { return { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 }; }
    function lerp(start, end, amt) { return (1 - amt) * start + amt * end; }

    // æ‰‹åŠ¿è¿Ÿæ»é€»è¾‘ (é˜²æŠ–)
    const PINCH_START = 0.035; 
    const PINCH_STOP = 0.06; 
    function detectPinch(landmarks, isCurrentlyPinching) {
        const d = dist(landmarks[4], landmarks[8]);
        return isCurrentlyPinching ? (d < PINCH_STOP) : (d < PINCH_START);
    }

    // --- æ ¸å¿ƒé€»è¾‘ï¼šç”»é¢é€‚é…ä¸ç»˜åˆ¶ ---

    function calculateVideoLayout(videoWidth, videoHeight) {
        // ç›®æ ‡ï¼šObject-Fit: Cover (å¡«æ»¡å±å¹•ï¼Œä¿æŒæ¯”ä¾‹ï¼Œè£åˆ‡å¤šä½™)
        const screenAspect = screenW / screenH;
        const videoAspect = videoWidth / videoHeight;
        
        let drawW, drawH, startX, startY;

        if (screenAspect > videoAspect) {
            // å±å¹•æ›´å®½ï¼Œä»¥å®½åº¦ä¸ºåŸºå‡†ï¼Œè£åˆ‡ä¸Šä¸‹
            drawW = screenW;
            drawH = screenW / videoAspect;
            startX = 0;
            startY = (screenH - drawH) / 2; // å±…ä¸­
        } else {
            // å±å¹•æ›´é«˜ï¼Œä»¥é«˜åº¦ä¸ºåŸºå‡†ï¼Œè£åˆ‡å·¦å³
            drawH = screenH;
            drawW = screenH * videoAspect;
            startX = (screenW - drawW) / 2; // å±…ä¸­
            startY = 0;
        }
        
        return { x: startX, y: startY, w: drawW, h: drawH };
    }

    // å°† MediaPipe çš„å½’ä¸€åŒ–åæ ‡ (0-1) æ˜ å°„åˆ° è£åˆ‡åçš„ç”»å¸ƒåæ ‡
    function mapCoordinates(normX, normY) {
        const layout = STATE.videoLayout;
        return {
            x: layout.x + normX * layout.w,
            y: layout.y + normY * layout.h
        };
    }

    function onResults(results) {
        // 1. è®¡ç®—é€‚é…å°ºå¯¸ (æ¯å¸§è®¡ç®—ä»¥é˜²çª—å£å˜åŒ–ï¼Œå®é™…å¯ä¼˜åŒ–)
        STATE.videoLayout = calculateVideoLayout(results.image.width, results.image.height);
        
        // 2. ç»˜åˆ¶è§†é¢‘èƒŒæ™¯ (ä¸å˜å½¢)
        ctx.clearRect(0, 0, screenW, screenH);
        ctx.drawImage(results.image, STATE.videoLayout.x, STATE.videoLayout.y, STATE.videoLayout.w, STATE.videoLayout.h);

        // 3. ç»˜åˆ¶ç¬”ç”»
        drawAllStrokes(ctx);

        // 4. æ‰‹åŠ¿å¤„ç†
        if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
            statusDiv.innerText = "æœªæ£€æµ‹åˆ°æ‰‹éƒ¨";
            STATE.isDrawing = false;
            return;
        }

        const hand = results.multiHandLandmarks[0];
        
        // è®¡ç®—æåˆä¸­ç‚¹ (å½’ä¸€åŒ–åæ ‡)
        const rawP = mid(hand[4], hand[8]);
        
        // æ˜ å°„åˆ°å±å¹•åæ ‡ (è§£å†³æ‹‰ä¼¸é—®é¢˜çš„å…³é”®)
        const mappedP = mapCoordinates(rawP.x, rawP.y);
        
        // åæ ‡å¹³æ»‘
        if (STATE.smoothedX === 0) { STATE.smoothedX = mappedP.x; STATE.smoothedY = mappedP.y; }
        else {
            STATE.smoothedX = lerp(STATE.smoothedX, mappedP.x, 0.4); // 0.4 å»¶è¿Ÿç³»æ•°ï¼Œè¶Šå°è¶Šå¹³æ»‘
            STATE.smoothedY = lerp(STATE.smoothedY, mappedP.y, 0.4);
        }
        
        const cursorPt = { x: STATE.smoothedX, y: STATE.smoothedY };

        // UI äº¤äº’æ£€æµ‹ (æ³¨æ„ï¼šCanvas CSS åšäº† scaleX(-1) ç¿»è½¬)
        // è§†è§‰ä¸Šçš„å·¦è¾¹æ˜¯ç‰©ç†å±å¹•çš„å·¦è¾¹ï¼Œä½†åœ¨ flipped canvas é‡Œåæ ‡æ˜¯ (width - x)
        const visualX = screenW - cursorPt.x;
        
        const isPinching = detectPinch(hand, STATE.isDrawing);
        checkUIInteraction(visualX, cursorPt.y, isPinching);

        if (isPinching) {
            if (STATE.tool === 'brush') {
                statusDiv.innerText = "âœï¸ ä¹¦å†™ä¸­...";
                drawBrushCursor(cursorPt, STATE.color, STATE.baseSize);
                handlePainting(cursorPt);
            } else if (STATE.tool === 'eraser') {
                statusDiv.innerText = "âš¡ æ©¡çš®æ“¦";
                drawEraserCursor(cursorPt);
                handleErasing(cursorPt);
            }
            STATE.isDrawing = true;
        } else {
            statusDiv.innerText = "ğŸ‘† å‡†å¤‡ä¸­ (æåˆæ‰‹æŒ‡ä¹¦å†™)";
            // ç»˜åˆ¶å¼•å¯¼å…‰æ ‡
            // åŒæ ·éœ€è¦æ˜ å°„é£ŸæŒ‡ä½ç½®
            const indexTip = mapCoordinates(hand[8].x, hand[8].y);
            drawCursor(indexTip, 'rgba(255,255,255,0.8)');
            STATE.isDrawing = false;
            STATE.activeStroke = null;
        }
    }

    // --- ç¬”ç”»é€»è¾‘ ---

    function handlePainting(pt) {
        if (!STATE.isDrawing || !STATE.activeStroke) {
            STATE.activeStroke = {
                points: [{x: pt.x, y: pt.y, w: STATE.baseSize}],
                color: STATE.color,
                // åŒ…å›´ç›’ç”¨äºæ©¡çš®æ“¦å¿«é€Ÿæ£€æµ‹
                bounds: { minX: pt.x, maxX: pt.x, minY: pt.y, maxY: pt.y }
            };
            STATE.strokes.push(STATE.activeStroke);
        } else {
            const points = STATE.activeStroke.points;
            const lastPt = points[points.length - 1];
            const d = dist(pt, lastPt);
            
            if (d > 2) { // è¿‡æ»¤å¾®å°ç§»åŠ¨
                // åŠ¨æ€ç²—ç»†ï¼šé€Ÿåº¦è¶Šå¿«è¶Šç»†
                const speed = Math.min(d, 20);
                const newWidth = Math.max(STATE.baseSize * (1 - speed/40), 2);
                
                // å®½åº¦å¹³æ»‘
                const smoothWidth = lerp(lastPt.w, newWidth, 0.2);
                
                const newPt = { x: pt.x, y: pt.y, w: smoothWidth };
                points.push(newPt);
                
                // æ›´æ–°åŒ…å›´ç›’
                const b = STATE.activeStroke.bounds;
                b.minX = Math.min(b.minX, pt.x); b.maxX = Math.max(b.maxX, pt.x);
                b.minY = Math.min(b.minY, pt.y); b.maxY = Math.max(b.maxY, pt.y);
            }
        }
    }

    function handleErasing(pt) {
        // å¯¹è±¡æ“¦é™¤ï¼šç¢°æ’æ£€æµ‹
        for (let i = STATE.strokes.length - 1; i >= 0; i--) {
            const s = STATE.strokes[i];
            // 1. åŒ…å›´ç›’é¢„æ£€
            if (pt.x < s.bounds.minX - 20 || pt.x > s.bounds.maxX + 20 ||
                pt.y < s.bounds.minY - 20 || pt.y > s.bounds.maxY + 20) continue;
            
            // 2. é€ç‚¹æ£€æµ‹
            for (let p of s.points) {
                if (dist(pt, p) < 20) {
                    STATE.strokes.splice(i, 1); // åˆ é™¤æ•´æ¡
                    return;
                }
            }
        }
    }

    function drawAllStrokes(ctx) {
        STATE.strokes.forEach(stroke => {
            const pts = stroke.points;
            if (pts.length < 2) return;

            ctx.beginPath();
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.strokeStyle = stroke.color;
            ctx.lineWidth = pts[0].w; // ä½¿ç”¨é¦–ç‚¹å®½åº¦ï¼Œå®é™…ä¸Šè´å¡å°”æ›²çº¿éš¾ä»¥å®Œç¾å˜å®½ï¼Œè¿™é‡Œå–è¿‘ä¼¼

            ctx.moveTo(pts[0].x, pts[0].y);
            
            // äºŒæ¬¡è´å¡å°”æ›²çº¿å¹³æ»‘
            for (let i = 1; i < pts.length - 2; i++) {
                const xc = (pts[i].x + pts[i+1].x) / 2;
                const yc = (pts[i].y + pts[i+1].y) / 2;
                ctx.quadraticCurveTo(pts[i].x, pts[i].y, xc, yc);
            }
            // å¤„ç†æœ€åä¸€æ®µ
            if (pts.length > 2) {
                const last = pts[pts.length-1];
                const prev = pts[pts.length-2];
                ctx.quadraticCurveTo(prev.x, prev.y, last.x, last.y);
            }
            ctx.stroke();
            
            // å¯é€‰ï¼šå¦‚æœæƒ³è¦æ›´å¥½çš„å˜å®½æ•ˆæœï¼Œå¯ä»¥å–æ¶ˆä¸Šé¢çš„ strokeï¼Œæ”¹ç”¨å¯†é›†ç”»åœ†ï¼Œä½†è¿™ä¼šæ¶ˆè€—æ›´å¤šæ€§èƒ½
            // é‰´äºè¦æ±‚â€œå¹³æ»‘â€ï¼Œè´å¡å°”æ›²çº¿æ˜¯æœ€ä½³é€‰æ‹©ã€‚
        });
    }

    // --- UI äº¤äº’ ---
    let lastClickTime = 0;
    function checkUIInteraction(visualX, visualY, isPinching) {
        if (!isPinching) return;
        const now = Date.now();
        if (now - lastClickTime < 500) return;

        const buttons = document.querySelectorAll('.tool-btn, .color-btn');
        buttons.forEach(btn => {
            const rect = btn.getBoundingClientRect();
            if (visualX >= rect.left && visualX <= rect.right && visualY >= rect.top && visualY <= rect.bottom) {
                
                if (btn.dataset.tool) {
                    const tool = btn.dataset.tool;
                    if (tool === 'clear') {
                        STATE.strokes = [];
                        statusDiv.innerText = "ç”»æ¿å·²æ¸…ç©º";
                    } else {
                        STATE.tool = tool;
                        document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                    }
                } else if (btn.dataset.color) {
                    STATE.color = btn.dataset.color;
                    STATE.tool = 'brush';
                    document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                    document.getElementById('btn-brush').classList.add('active');
                }
                lastClickTime = now;
            }
        });
    }

    // --- å…‰æ ‡ç»˜åˆ¶ ---
    function drawCursor(pt, color) {
        ctx.beginPath(); ctx.arc(pt.x, pt.y, 6, 0, Math.PI*2);
        ctx.fillStyle = color; ctx.fill(); 
        ctx.strokeStyle = 'rgba(0,0,0,0.3)'; ctx.lineWidth = 1; ctx.stroke();
    }
    function drawBrushCursor(pt, color, size) {
        ctx.beginPath(); ctx.arc(pt.x, pt.y, size/2, 0, Math.PI*2);
        ctx.fillStyle = color; ctx.globalAlpha = 0.8; ctx.fill();
        ctx.globalAlpha = 1; ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.stroke();
    }
    function drawEraserCursor(pt) {
        ctx.beginPath(); ctx.arc(pt.x, pt.y, 15, 0, Math.PI*2);
        ctx.strokeStyle = '#ff5252'; ctx.lineWidth = 2; ctx.stroke();
        ctx.beginPath(); ctx.moveTo(pt.x-8, pt.y-8); ctx.lineTo(pt.x+8, pt.y+8); ctx.stroke();
        ctx.moveTo(pt.x+8, pt.y-8); ctx.lineTo(pt.x-8, pt.y+8); ctx.stroke();
    }

    // çª—å£å¤§å°æ”¹å˜æ—¶é‡ç½®
    window.addEventListener('resize', () => {
        screenW = window.innerWidth;
        screenH = window.innerHeight;
        canvasElement.width = screenW;
        canvasElement.height = screenH;
    });

</script>
</body>
</html>